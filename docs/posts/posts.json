[
  {
    "path": "posts/welcome/",
    "title": "Setting Up Supervised Learning Probems",
    "description": {},
    "author": [
      {
        "name": "Kris Sankaran",
        "url": "https://krisrs1128.github.com/LSLab"
      }
    ],
    "date": "2023-05-21",
    "categories": [],
    "contents": "\n\n\n\nWe are making predictions all the time, often without realizing it. For\nexample, imagine we are waiting at a bus stop and want to guess how long it will\nbe before a bus arrives. We can combine many sources of evidence,\nHow many people are currently at the stop? If there are more people, we think\na bus might arrive soon.\nWhat time of day is it? If it’s during rush hour, we would expect more\nfrequent service.\nWhat is the weather like? If it is poor weather, we might expect delays.\netc.\nTo think about the process formally, we could imagine a vector \\(\\mathbf{x}_i \\in \\mathbb{R}^{D}\\) reflecting \\(D\\) characteristics of our environment.\nIf we collected data about how long we actually had to wait, call it \\(y_i\\), for\nevery day in a year, then we would have a dataset\n\\[\\begin{align*}\n\\left(\\mathbf{x}_1, y_1\\right) \\\\\n\\left(\\mathbf{x}_2, y_2\\right) \\\\\n\\vdots \\\\\n\\left(\\mathbf{x}_{365}, y_{365}\\right) \\\\\n\\end{align*}\\]\nand we could try to summarize the relationship \\(\\mathbf{x}_i \\to y_i\\). Methods\nfor making this process automatic, based simply on a training dataset, are\ncalled supervised learning methods.\nIn the above example, the inputs were a mix of counts (number of people at\nstop?) and categorical (weather) data types, and our response was a nonnegative\ncontinuous value. In general, we could have arbitrary data types for either\ninput or response variable. A few types of outputs are so common that they come\nwith their own names,\n\\(y_i\\) continuous \\(\\to\\) regression\n\\(y_i\\) categorical \\(\\to\\) classification\nFor example,\nTrying to determine whether a patient’s disease will be cured by a\ntreatment is a classification problem – the outcomes are either yes, they will\nbe cured, or no, they won’t.\nTrying to estimate the crop yield of a plot of\nfarmland based on a satellite image is a regression problem – it could be any\ncontinuous, nonnegative number.\nThere are in fact many other types of responses (ordinal, multiresponse,\nsurvival, functional, image-to-image, …) each which come with their own names\nand set of methods, but for our purposes, it’s enough to focus on regression and\nclassification.\nThere is a nice geometric way of thinking about supervised learning. For\nregression, think of the inputs on the \\(x\\)-axis and the response on the\n\\(y\\)-axis. Regression then becomes the problem of estimating a one-dimensional\ncurve from data.\n\n\n\nIn higher-dimensions, this becomes a surface.\n\n\n\nIf some of the inputs are categorical (e.g., poor vs. good weather), then the\nregression function is no longer a continuous curve, but we can still identify\ngroup means.\nClassification has a similar geometric interpretation, except instead of a\ncontinuous response, we have categorical labels. We can associate classes with\ncolors. If we have only one input, classification is the problem of learning\nwhich regions of the input are associated with certain colors.\n\n\n\nIn higher-dimensions, the view is analogous. We just want to find boundaries\nbetween regions with clearly distinct colors. For example, for disease\nrecurrence, blood pressure and resting heart rate might be enough to make a good\nguess about whether a patient will have recurrence or not.\n\n\n\nModel Classes\nDrawing curves and boundaries sounds simple, but is a surprisingly difficult\nproblem, especially when the number of potentially informative features \\(D\\) is\nlarge. It helps to have predefined types of curves (and boundaries) that we can\nrefer to and use to partially automate the process of supervised learning. We’ll\ncall an example of these predefined curve types a “model class.” Let’s just build some intuition about what each model class looks\nlike and how we might be able to fit it with data.\nLinear Models\nMaybe the simplest curve is a linear one,\n\\[\\begin{align*}\nf_{b}\\left(x\\right) = b_0 + b_1 x_1.\n\\end{align*}\\]\nHere, \\(b_0\\) gives the \\(y\\)-intercept and \\(b_1\\) gives the slope.\n\n\n\nWhen we have many input features, the equivalent formula is\n\\[\\begin{align*}\nf_{b}\\left(x\\right) = b_0 + b_1 x_1 + \\dots + b_{D}x_{D} := b^{T}x,\n\\end{align*}\\]\nwhere I’ve used the dot-product from linear algebra to simplify notation (after having appended a 1). This kind of model is called a linear regression model.\n\n\n\nHow do we find a \\(b\\) that fits the data well? We can try to optimize a “loss”\nfunction. This measures the quality of the fitted line. For linear regression, a\ngood choice is squared error loss,\n\\[\\begin{align*}\nL\\left(b\\right) = \\sum_{i = 1}^{N} \\left(y_i - b^{T}x_{i}\\right)^2.\n\\end{align*}\\]\nFor classification, we can imagine drawing a linear boundary. For simplicity,\nwe’ll assume we have only two classes, though a similar partition of the space\ncan be made for arbitrary numbers of classes.\n\n\n\nTo describe this, we need to define a direction \\(b\\) perpendicular to the\nboundary. We will say that whenever\n\\[\\begin{align*}\nf_{b}\\left(x\\right) = \\frac{1}{1 + \\text{exp}\\left(b^T x\\right)}\n\\end{align*}\\]\nis larger than 0.5, we’re in the red region, and whenever it’s smaller than\n0.5, we’re in the purple region. This kind of model is called a logistic regression model.\n\n\n\nWe need a loss function for logistic regression too. In theory, we could\ncontinue to use squared error loss, but we can do better by considering the fact\nthat the true response is only one of two values. To make things concrete, say\nthat \\(y_i = 1\\) whenever it is an red point, otherwise \\(y_i = 0\\). We can use\nbinary cross-entropy loss,\n\\[\\begin{align*}\n-\\left[\\sum_{i = 1}^{N} y_i \\log\\left(f_{b}\\left(x_i\\right)\\right) + \\left(1 - y_i\\right) \\log\\left(1 - f_{b}\\left(x_i\\right)\\right)\\right]\n\\end{align*}\\]\nTo understand this loss, note that each term decomposes into either the blue or\nred curve, depending on whether the \\(y_i\\) is 1 or 0.\n\n\n\nIf 1 is predicted with probability 1, then there is no loss (and conversely for\n0). The loss increases the further the predicted probability is from the true\nclass.\nLet’s fit a linear regression in code. Below, I’m loading a dataset about\ndiabetes disease progression. The response \\(y\\) is disease severity one year\nafter diagnosis, it ranges from 25 (low severity) to 246 (high severity). There\nare \\(D = 10\\) numeric predictors; below I print 4 samples corresponding to the first 5 features.\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets, linear_model\n\nX, y = datasets.load_diabetes(return_X_y=True)\nX[:4, :5] # first five predictors\narray([[ 0.03807591,  0.05068012,  0.06169621,  0.02187239, -0.0442235 ],\n       [-0.00188202, -0.04464164, -0.05147406, -0.02632753, -0.00844872],\n       [ 0.08529891,  0.05068012,  0.04445121, -0.00567042, -0.04559945],\n       [-0.08906294, -0.04464164, -0.01159501, -0.03665608,  0.01219057]])\ny[:4] # example response\narray([151.,  75., 141., 206.])\n\nLet’s now fit a linear model from \\(\\mathbf{x}_1, \\dots, \\mathbf{x}_{N}\\) to \\(y\\).\nThe first line tells python that we are using a LinearRegression model class.\nThe second searches over coefficients \\(b\\) to minimize the squared-error loss\nbetween the \\(b^T x_i\\) and \\(y_i\\). The third line prints out the fitted coefficient\n\\(\\hat{b}\\).\n\nmodel = linear_model.LinearRegression()\nmodel.fit(X, y)\nLinearRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LinearRegressionLinearRegression()\nmodel.coef_ # fitted b coefficients\narray([ -10.0098663 , -239.81564367,  519.84592005,  324.3846455 ,\n       -792.17563855,  476.73902101,  101.04326794,  177.06323767,\n        751.27369956,   67.62669218])\n\nLet’s do the same thing for a logistic regression. This time, we’ll use the\nPalmer’s Penguins dataset, which tries to classify penguins into one of three\ntypes based on their appearance. For example, two of the features are bill\nheight and bill depth (figure from Allison Horst’s palmerspenguins\npackage).\n\n\n\nWe’ll read the data from a public link and print the first few rows.\n\nimport pandas as pd\n\npenguins = pd.read_csv(\"https://raw.githubusercontent.com/krisrs1128/stat679_code/0330ce6257ff077c5d4ed9f102af6be089f5c486/examples/week6/week6-4/penguins.csv\")\npenguins.head()\n  species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  body_mass_g     sex  year\n0  Adelie  Torgersen            39.1           18.7                181         3750    male  2007\n1  Adelie  Torgersen            39.5           17.4                186         3800  female  2007\n2  Adelie  Torgersen            40.3           18.0                195         3250  female  2007\n3  Adelie  Torgersen            36.7           19.3                193         3450  female  2007\n4  Adelie  Torgersen            39.3           20.6                190         3650    male  2007\n\nWe’ll predict species using just bill length and depth. First, let’s make a\nplot to see how easy / difficult it will be to create a decision boundary.\n\nggplot(py$penguins) +\n  geom_point(aes(bill_length_mm, bill_depth_mm, col = species)) +\n  scale_color_manual(values = c(\"#3DD9BC\", \"#6DA671\", \"#F285D5\")) +\n  labs(x = \"Bill Length\", y = \"Bill Depth\")\n\n\nIt seems like we should be able to draw nice boundaries between these\nclasses. Let’s fit the model.\n\nmodel = linear_model.LogisticRegression()\npenguins = penguins.dropna()\nX, y = penguins[[\"bill_length_mm\", \"bill_depth_mm\"]], penguins[\"species\"]\nmodel.fit(X, y)\nLogisticRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LogisticRegressionLogisticRegression()\npenguins[\"y_hat\"] = model.predict(X)\n\nThe plot below compares the predicted class (left, middle, and right panels)\nwith the true class (color). We get most of the samples correct, but have a few\nmissclassifications near the boundaries.\n\nggplot(py$penguins) +\n  geom_point(aes(bill_length_mm, bill_depth_mm, col = species)) +\n  scale_color_manual(values = c(\"#3DD9BC\", \"#6DA671\", \"#F285D5\")) +\n  labs(x = \"Bill Length\", y = \"Bill Depth\") +\n  facet_wrap(~ y_hat)\n\n\nExercise: Repeat this classification, but using at least two additional\npredictors.\nSparse Linear Models\nIn many cases, we will have recorded many types of features – coordinates\nof \\(x_{i}\\) – that are not actually related to the response. A model that knows\nto ignore irrelevant features will do better than a model that tries to use\nall of them. This is the main idea behind using sparsity in linear regression.\nWe again fit the model\n\\[\\begin{align*}\nf_{b}\\left(x\\right) = b_0 + b_1 x_1 + \\dots + b_{D}x_{D} := b^{T}x,\n\\end{align*}\\]\nbut we make the assumption that many of the \\(b_{d}\\) are exactly 0. Graphically,\nwe imagine that the response does not change at all as we change some of the\ninputs, all else held equal.\n\n\n\nThe same idea can be applied to logistic regression. In this case, having a\ncoefficient \\(b_d = 0\\) means that the probabilities for different class labels\ndo not change at all as features \\(x_d\\) is changed.\n\n\n\nTo implement sparse linear regression using sklearn, we can use the\nElasticNet class. We’ll work with a dataset of American Baseball sports\nstatistics. The task is to predict each player’s salary based on their batting\nstatistics.\n\nbaseball = pd.read_csv(\"https://github.com/krisrs1128/naamii_summer_2023/raw/main/assets/baseball.csv\")\nbaseball.head()\n              player    salary     AtBat      Hits     HmRun      Runs       RBI  ...    CWalks   LeagueN  DivisionW   PutOuts   Assists    Errors  NewLeagueN\n0        -Alan Ashby -0.135055 -0.601753 -0.594542 -0.527545 -1.203816 -0.521069  ...  0.434506  1.056743   0.979299  1.219174 -0.522196  0.212946    1.073007\n1       -Alvin Davis -0.123972  0.511566  0.491323  0.728577  0.440675  0.792549  ...  0.010353 -0.942706   0.979299  2.105095 -0.253380  0.818404   -0.928417\n2      -Andre Dawson -0.079637  0.626971  0.735088  0.956963  0.401520  1.024364  ...  0.354977  1.056743  -1.017256 -0.324044 -0.742763 -0.846605    1.073007\n3  -Andres Galarraga -0.985164 -0.561022 -0.461579 -0.184967 -0.616498 -0.366526  ... -0.860675  1.056743  -1.017256  1.837176 -0.542874 -0.695240    1.073007\n4   -Alfredo Griffin  0.474541  1.292248  1.355583 -0.870124  0.753911 -0.018804  ... -0.250955 -0.942706   0.979299 -0.031118  2.083253  2.483412   -0.928417\n\n[5 rows x 21 columns]\nX, y = baseball.iloc[:, 2:], baseball[\"salary\"]\ny = (y - y.mean()) / y.std() # standardize\n\nThe block below fits the Elastic Net model and saves the coefficients \\(\\hat{b}\\).\nNotice that most of them are 0 – only a few of the features make a big difference\nin the salary.\n\nmodel = linear_model.ElasticNet(alpha=1e-1, l1_ratio=0.5) # in real life, have to tune these parameters\nmodel.fit(X, y)\nElasticNet(alpha=0.1)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.ElasticNetElasticNet(alpha=0.1)\ny_hat = model.predict(X)\n\nbeta_hat = model.coef_ # notice the sparsity\nbeta_hat\narray([ 0.        ,  0.17423133,  0.        ,  0.        ,  0.        ,\n        0.1050172 ,  0.        ,  0.        ,  0.07963389,  0.06285448,\n        0.12726386,  0.16911053,  0.        ,  0.        , -0.0988662 ,\n        0.12489593, -0.        , -0.        ,  0.        ])\n\nWe can confirm that the predictions are correlated relatively well with the\ntruth.\n\nbaseball <- data.frame(py$X, y = py$y, y_hat = py$y_hat)\nggplot(baseball) +\n  geom_point(aes(y, y_hat)) +\n  labs(x = \"True IMDB Rating\", y = \"Predicted IMDB Rating\")\n\n\nTree-based Models\nTree-based models fit a different class of curves. To motivate them,\nconsider making a prediction for the bus time arrival problem using the\nfollowing diagram,\n\n\n\nNotice that we can use the same logic to do either regression or classification.\nFor regression, we associate each “leaf” at the bottom of the tree with a\ncontinuous prediction. For classification, we associate leaves with\nprobabilities for different classes. It turns out that we can train these models\nusing squared error and cross-entropy losses as before, though the details are\nbeyond the scope of these notes.\nIt’s not immediately obvious, but these rules are equivalent to drawing\ncurves that are piecewise constant over subsets of the input space. Let’s\nconvince ourselves using some pictures. First, notice that a tree with a single\nsplit is exactly a “curve” that takes on two values, depending on the split\npoint,\n\n\n\nIf we split the same variable deeper, it creates more steps,\nWhat if we had two variables? Depending on the order, of the splits, we create\ndifferent axis-aligned partitions,\n\n\n\nQ: What would be the diagram if I had switched the order of the splits (traffic before rain)?\nA very common variation on tree-based models computes a large ensemble of\ntrees and then combines their curves in some way. How exactly they are combined\nis beyond the scope of these notes, but this is what random forests and gradient\nboosted decision trees are doing in the background.\nWe can implement these models in sklearn using RandomForestRegressor /\nRandomForestClassifier, and GradientBoostingRegressor /\nGradientBoostingClassifier. Let’s just see an example of a boosting classifier\nusing the penguins dataset. The fitting / prediction code is very similar to\n\nfrom sklearn.ensemble import GradientBoostingClassifier\nmodel = GradientBoostingClassifier()\nX, y = penguins[[\"bill_length_mm\", \"bill_depth_mm\"]], penguins[\"species\"]\nmodel.fit(X, y)\nGradientBoostingClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GradientBoostingClassifierGradientBoostingClassifier()\npenguins[\"y_hat\"] = model.predict(X)\n\nWe use the same visualization code to check predictions against the truth. The\nboosting classifier makes no mistakes on the training data.\n\nggplot(py$penguins) +\n  geom_point(aes(bill_length_mm, bill_depth_mm, col = species)) +\n  scale_color_manual(values = c(\"#3DD9BC\", \"#6DA671\", \"#F285D5\")) +\n  labs(x = \"Bill Length\", y = \"Bill Depth\") +\n  facet_wrap(~ y_hat)\n\n\nRelationships across classes\nThe diagram below summarizes the relationships across elements of the model\nclass.\n\n\n\nWhen should we use which of these approaches? Here are some relative\nstrengths and weaknesses.\n\nStrengths\nWeaknesses\nLinear / Logistic Regression\n* Often easy to interpret* No tuning parameters* Very fast to train\n* Unstable when many features to pick from* Can only fit linear curves / boundaries (though, see featurization notes)\nSparse Linear / Logistic Regression\n* Often easy to interpret* Stable even when many features to pick from* Very fast to train\n* Can only fit linear curves / boundaries\nTree-based Classification / Regression\n* Can fit nonlinear functions of inputs\n* Can be slow to train* Somewhat harder to interpret\nTry matching models to responses in the examples below,\nQ1: We want to predict whether a patient has a disease given just their genetic\nprofile. There are 1000 genes that can serve as predictors. There are only two\npossible responses.\nQ2: A user on a site has been watching (too many…) episodes of Doctor\nWho. How many more minutes will they remain on the site today? As predictors,\nyou have features of their current and past viewing behavior (e.g.,\ncurrent time of day, number of hours on the site per week for each of the last 4 weeks,\netc.). We suspect that there are important nonlinear relationships between\nthese predictors and the response.\nQ3: We are trying to predict the next hour’s total energy production in a wind\nfarm. We have a years worth of past production and weather data, but right now,\nwe just want a baseline using current wind speed and the last hour’s production.\nThe answers are,\nA1: Sparse logistic regression. We have two classes, and most of the genes are unlikely to be relevant for classification.\nA2: A tree-based method, like random forests or gradient boosting. This is because we anticipate a nonlinear relationship.\nA3: Linear regression. The response is continuous and we just need a baseline\nusing two predictors.\n",
    "preview": "posts/welcome/figures/curve-1d.png",
    "last_modified": "2023-05-20T22:20:13-05:00",
    "input_file": {}
  }
]
